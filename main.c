//
// main.c
//

#include "aes_cipher.h"

void print_block(const char *label, const uint8_t *block)
{
    printf("\n%s:", label);
    for (uint8_t i = 0; i < AES_BLK_LEN; i++)
    {
        if (i % 4 == 0) printf("\n");
        printf("0x%02X ", block[i]);
    }

    printf("\n");
}

int test_aes_block(uint8_t *input, void (*aes_encrypt_block)(uint8_t *), void (*aes_decrypt_block)(uint8_t *))
{
    uint8_t ref_input[AES_BLK_LEN];
    memcpy(ref_input, input, AES_BLK_LEN);

    print_block("Plain", input);

    aes_encrypt_block(input);
    print_block("Encrypted", input);

    aes_decrypt_block(input);
    print_block("Decrypted", input);

    for (uint8_t i = 0; i < AES_BLK_LEN; i++) {
        if (input[i] != ref_input[i]) {
            printf("\n\nFAILED!\n");
            return 0;
        }
    }

    printf("\n\nSUCCESS!\n");
    return 1;
}

int main()
{
    printf("AES_EXP_KEY_LEN: %u\n", AES_EXP_KEY_LEN);

    uint8_t key_matrix[Nb][Nk] = { 0x00 };

    uint8_t output[AES_BLK_LEN]  = { 0x00 };

#ifdef ROW_MAJOR_MODE
    uint8_t  input[AES_BLK_LEN]  = { 0x32, 0x88, 0x31, 0xE0, 0x43, 0x5A, 0x31, 0x37, 0xF6, 0x30, 0x98, 0x07, 0xA8, 0x8D, 0xA2, 0x34 };
#else
    uint8_t  input[AES_BLK_LEN]  = { 0x32, 0x43, 0xF6, 0xA8, 0x88, 0x5A, 0x30, 0x8D, 0x31, 0x31, 0x98, 0xA2, 0xE0, 0x37, 0x07, 0x34 };
#endif

#if AES_KEY_LEN_CONF == 128
    uint8_t key[4 * Nk] = { 0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C };

    uint8_t key_row_major[4 * Nk] = {
        0x2B, 0x28, 0xAB, 0x09,
        0x7E, 0xAE, 0xF7, 0xCF,
        0x15, 0xD2, 0x15, 0x4F,
        0x16, 0xA6, 0x88, 0x3C
    };
#elif AES_KEY_LEN_CONF == 192
    uint8_t key[4 * Nk] = { 0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C, 
                            0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6 };

    uint8_t key_row_major[4 * Nk] = {
        0x2B, 0x28, 0xAB, 0x09, 0x2B, 0x28,
        0x7E, 0xAE, 0xF7, 0xCF, 0x7E, 0xAE,
        0x15, 0xD2, 0x15, 0x4F, 0x15, 0xD2,
        0x16, 0xA6, 0x88, 0x3C, 0x16, 0xA6
    };
#elif AES_KEY_LEN_CONF == 256
    uint8_t key[4 * Nk] = { 0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C,
                            0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C };

    uint8_t key_row_major[4 * Nk] = {
        0x2B, 0x28, 0xAB, 0x09, 0x2B, 0x28, 0xAB, 0x09,
        0x7E, 0xAE, 0xF7, 0xCF, 0x7E, 0xAE, 0xF7, 0xCF,
        0x15, 0xD2, 0x15, 0x4F, 0x15, 0xD2, 0x15, 0x4F,
        0x16, 0xA6, 0x88, 0x3C, 0x16, 0xA6, 0x88, 0x3C
    };
#endif

#ifdef ROW_MAJOR_MODE
    //
    // You can still keep the key in column-major and do the mapping
    //
    /*
    for (uint8_t n = 0; n < (Nb * Nk); n++)
        key_matrix[n % Nb][n / Nb] = key[n];

    expand_key(key_matrix, aes_expanded_key);
    */

    //
    // Or if the key is also in row-major, just pass it as 1D array
    //
    expand_key((uint8_t (*)[Nk])key_row_major, aes_expanded_key);
#else
    for (uint8_t n = 0; n < (Nb * Nk); n++)
        key_matrix[n % Nb][n / Nb] = key[n];

    expand_key(key_matrix, aes_expanded_key);

    for (uint8_t n = 0; n < (Nb * Nr) + Nb; n += Nb)
    {
        SWAP_SYMM_OFF_DIAG_ELEMENTS(aes_expanded_key, n);
    }
#endif

    test_aes_block(input, aes_encrypt_block, aes_decrypt_block);

    return 0;
}
